\documentclass[a4paper, 12pt]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{fancyhdr}
\usepackage{url}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}
\usepackage{listings}

\pagestyle{fancy}
\rhead{March 14, 2016, s1115104}
\lhead{INFR11098: Secure Programming Coursework}


\begin{document}

\section*{Bugs in OpenSSH}
\setcounter{section}{1}

\subsection{CVE-2016-0777 - Information Leak}
OpenSSH client versions between 5.4 and 7.1 are vulnerable to an information leak. The information leak occurs due to an experimental \textit{roaming} feature enabled by default. The \textit{roaming} feature allows a client to buffer input and re-send the buffer to an OpenSSH server on re-connect. This feature, however, uses an unsafe \texttt{malloc} call to allocate a buffer on the heap. A potential attacker may be able to read data from a previously de-allocated buffer, including private keys of the client \cite{QualisOpenSSH}.

The immediate remedial action is to update \texttt{ssh\_config} (global, or all local) and include \texttt{UseRoaming no} to disable the roaming feature. Alternatively, all \texttt{ssh} sessions can be executed with the \texttt{UseRomaing no} flag. The second immediate remedial action is to re-issue all private keys as the attack may have been exploited in the 'wild' allowing for an attacker to have already stolen the private key.

\subsection{CVE-2016-0778 - Buffer Overflow}
OpenSSH client versions 5.x, 6.x and 7.1.p2 \cite{NVD_CVE-201600778} are vulnerable to a file descriptor heap buffer overflow causing a denial of service or arbitrary code execution \cite{RedHat_CVE-201600778}. In order for this vulnerability to be exploited, two non-default configurations of the OpenSSH client are required - "ProxyCommand, and either ForwardAgent (-A) or ForwardX11 (-X)" \cite{QualisOpenSSH}.

The immediate remedial action is the same as for \textit{CVE-2016-0777}, \texttt{roaming} should be disabled and private keys should be re-issued.

\setcounter{section}{1}
\section*{2}
A CVSS score is an attempt at standardization of the seriousness of a vulnerability given its \textit{exploitability metrics}. The scores range from 0 to 10 with 10 being the most severe. Each metric contributes to the overall seriousness of an exploit, the total being used as the \textit{base score}.

\setcounter{section}{1}
\subsection*{Exploitability Metrics}
\begin{multicols}{2}
  \begin{enumerate}
      \item Attack Vector (AV)
          \begin{enumerate}
              \item Network (AV:N)
              \item Adjacent Network (AV:A)
              \item Local (AV:L)
              \item Physical (AV:P)
          \end{enumerate}

      \item Access Complexity (AC)
          \begin{enumerate}
              \item Low (AC:L)
              \item High (AC:H)
          \end{enumerate}

      \item Privileges Required (PR)
          \begin{enumerate}
              \item None (PR:N)
              \item Low (PR:L)
              \item High (PR:H)
          \end{enumerate}

      \item User Interaction (UI)
          \begin{enumerate}
              \item None (UI:N)
              \item Required (UI:R)
          \end{enumerate}

      \item Scope (S)
          \begin{enumerate}
              \item Unchanged (S:U)
              \item Changed (S:C)
          \end{enumerate}

      \item Confidentiality Impact (C)
          \begin{enumerate}
              \item None (C:N)
              \item Low (C:L)
              \item High (C:H)
          \end{enumerate}

      \item Integrity Impact (I)
          \begin{enumerate}
              \item None (I:N)
              \item Low (I:L)
              \item High (I:H)
          \end{enumerate}

      \item Availability Impact (A)
          \begin{enumerate}
              \item None (A:N)
              \item Low (A:L)
              \item High (A:H)
          \end{enumerate}
  \end{enumerate}
\end{multicols}

\textit{CVE-2016-0777} can be exploited over the network (AV:N), an attacker can expect repeated success of the attack as the complexity is low (AC:L), the exploit only requires user permissions (PR:L), it does not require any user interaction (UI:N), it comprises high confidentiality impact (C:H), there is no integrity impact (I:N) and it does not affect availability (A:N). The CVE is characterized as having severity of \textit{Medium (4.0-6.9)}.

\textit{CVE-2016-0778} can be exploited over the network (AV:N), it is low in exploit complexity (AC:L), does not require any special privilege (PR:N), no user interaction is required (UI:N) and the impact is high for confidentiality (C:H), high for integrity (I:H) and high for availability (A:H). The CVE is characterized with severity \textit{Cricial (9.0 - 10.0)}.

CVE-2016-0778 is more severe based on the score.

\setcounter{section}{2}
\section*{3}
Firstly, a code review process would have increased the chances of finding the buffer overflow vulnerability in CVE-2016-077. The code review could initially focus on the correctness of the implementation, however, it should also consider real world statistics on common vulnerabilities and focus on mitigation of such scenarios (CR1.1: 18) \cite{BSIMM6-CodeReview}.

Secondly, automated tools to check for the usage of commonly vulnerable APIs could be used to identify potential attack vectors before the code is deployed. This activity involved using real world data on vulnerability analysis and the respective security issues within the implementation to create an early warning system of unsafe API usage (CR1.4:55) \cite{BSIMM6-CodeReview}.

Thirdly, the operation of an official bug bounty program could lead to a higher number of vulnerabilities discovered as it provides an incentive for security researchers to analyze the application (CMVM3.4) \cite{BSIMM6-BugBounty}. The vulnerabilities could have been discovered by independent testing and study of the source code.

\setcounter{section}{3}
\section*{4}
In order to consider the relative merits of switching away from OpenSSH to the new system (let us call the system NewSSH), we have evaluate a range of aspects such as the exposure minimization, the operational model of the server (including other software dependency) with NewSSH, the development and maintenance principles of NewSSH as well as the the metrics used to evaluate the relative gain from switching to NewSSH.

Firstly, theoretically switching to NewSSH can mitigate exposure to vulnerabilities. For example, a vulnerability found in OpenSSH may no longer have any impact on our system running NewSSH. This assumption, however, relies entirely on the implementation of NewSSH. A vulnerability exploiting the specification protocol of SSH may render both systems equally vulnerable. By switching to NewSSH, we are only protecting ourselves from vulnerabilities found in OpenSSH, not vulnerabilities that may be discovered in NewSSH.

Secondly, the operational model of the SSH server is important. A server side switch from OpenSSH to NewSSH may not be able to protect against vulnerabilities found in the client side either application. If the majority of users of the SSH server maintain their usage of OpenSSH, then switching to NewSSH has not decreased our exposure to client side vulnerabilities. This is in fact the case of CVE-2016-0777/8. Additionally, a closed source or a proprietary implementation of NewSSH may in fact increase exposure due to undiscovered vulnerabilities as well as making an object analysis of the security model of NewSSH difficult to obtain.

Thirdly, the development and maintenance principles of NewSSH play an integral role. It is generally assumed that a widely adopted open source application will have had a large number of code reviewers and security researches scrutinizing the source code and patching vulnerabilities as quickly as possible. On the other hand, a potentially closed source or less popular implementation may have a significantly lower number of reviewers and experts involved in the development cycle.

Moreover, the number of CVEs or major vulnerabilities found in either application is not a reasonable indicator of the level of security provided by either application. It could be argued that the larger the number of CVEs reported, the more secure an application ought to be. Alternatively, considering the popularity of the package and the development principles (closed/open source) will affect the number of vulnerabilities discovered. This is due to a larger attack surface in terms of cost per client/server exploitable from the point of view of the attacker. More popular applications attract more attention and therefore also have a larger number of CVEs.

Furthermore, the number of CVEs in itself is not an indicator of security. Each CVE has a severity level, and therefore one would have to compare the severity of each CVE (score) rather than the total count.

I believe that the reasoning provided by my friend is insufficient to make an informed decision on whether switching away from OpenSSH would be beneficial. A deep analysis of both systems would be required in order to make a better informed decision.

\newpage
\section*{Buffer Overflow}
\setcounter{section}{1}

\newpage
\section*{Web Security}
\setcounter{section}{1}

\section*{1 XSS}
An Cross Site Scripting (XSS) attack generally takes the form of malicious user input which is exposed to other users. A such input may include scripting elements allowing an attacker to modify the behavior of the victims view.

Generally, for an XSS attack to be useful, it is desirable to perform an XSS attack in areas of the site restricted to users with a certain level of permission - for example after logging in or in administration mode.

In order to perform an XSS attack on the Image Voting System, we first analyze the system behavior. By logging in as a regular user, we can observe the behavior of the system, paying particular attention to areas where user input is used as part of the site's output. For initial analysis of the site, Chrome Web Developer tools with network and source code analysis suffice to obtain a better picture of the underlying system.

Firstly, we perform the following actions:
\begin{enumerate}
  \item Log in with \texttt{user1:user1}
    \item Post a url such as \texttt{\url{https://imgs.xkcd.com/comics/toasts.png}}
    \item Inspect the returned response after submission
    \item Post non-url text such as \texttt{<div>'"</div>} and observe the exact format of the response
\end{enumerate}

With the above simple steps, we can already make an educated guess on how the server is implemented, we can derive the following:

\begin{itemize}
  \item The Server side processor is PHP 5.5.9
    \item X-XSS-Protection header is set to 0
    \item The API to post a link is \texttt{HTTP POST http://localhost:8080/index.php} with form data containing the \texttt{link} attribute with the url we submitted.
    \item The response is rendered inside an \texttt{<img src='\url{https://imgs.xkcd.com/comics/toasts.png}'>} element
    \item Non-URL text appears to not be sanitized and is rendered as-is inside the \texttt{src} attribute
\end{itemize}

Armed with this knowledge, we can craft an XSS attack by ensuring we break out of the closing quote as part of our request and inject malicious code. The following does the trick as well as covers up the malformed request by also displaying an image.

\texttt{\linebreak' style="display: none" />
\linebreak<script>alert("Hello World!")</script>
\linebreak<img src='//imgs.xkcd.com/comics/toasts.png
}
\linebreak

The resulting site will display the following:

\lstinputlisting[language=HTML]{xss.html}

Any visitor of the site will now receive an \texttt{index.php} site containing our malicious script. A serious XSS attack could attempt to steal login credentials (and send them to C\&C) and gain access to a user's account or perform any other action while acting as the currently logged in user.

\section*{2 CSRF}
A Cross Site Request Forgery (CSRF) attack aims to exploit a another user (victim) to perform an action which they did not intend to make. In order to perform a CSRF attack, we need to understand the system implementation and what action we may want to utilize perform the exploit. In order to gain this insight, let us perform a few actions:

\begin{itemize}
  \item Submit an image \texttt{\url{https://imgs.xkcd.com/comics/toasts.png}}
    \item Click 'Vote for me' on David's image
    \item Click 'Vote for me' on our own image
\end{itemize}

From the above actions, we know the following:
\begin{itemize}
  \item We are \texttt{user1}
  \item Voting for David makes an \texttt{HTTP GET http://localhost:8080/vote.php?vote=david}, presumably voting for user1 would only require changing the query parameters
    \item Voting for ourselves fails with an check on the currently logged in user, we can confirm voting for user1 requires to change the query params.
\end{itemize}

Therefore, we would like to get other users (victims) to unknowingly vote for our own image. We can notice that voting is a GET method, which is incorrectly implemented on the server as a GET action ought to be idempotent, however, in this case it causes side effects - increments vote counter. When a browser is presented with a request to retrieve an image, it will make an \texttt{HTTP GET [url]} request to retrieve the content. The browser cannot distinguish an action such as voting from retrieving an image and therefore, we can use the url API of the 'Vote' action to be fetched by the victims browser and in fact vote for us. To do this, we craft can simply insert \texttt{http://localhost:8080/vote.php?vote=user1} as the image url. This will, however not render an image and may appear suspicious. Instead, we can hide the request inside a \texttt{background-image} style property. Inserting the following will do the trick:

\texttt{
\newline //imgs.xkcd.com/comics/toasts.png'
\newline style="background-image: url('vote.php?vote=user1')" '}

When we (user1) view the site, the count is not incremented as the server prevents us doing so - just as if we clicked the 'Vote for me' button on our own image.

When any other users (victims) view the site, the browser will make a GET request with their credentials and execute the vote. What's more, every reload of the site will increment the vote further.

\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}