\documentclass[a4paper, 12pt]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{fancyhdr}
\usepackage{url}
\usepackage[margin=1in]{geometry}
\usepackage{multicol}
\usepackage{listings}

\pagestyle{fancy}
\rhead{March 14, 2016, s1115104}
\lhead{INFR11098: Secure Programming Coursework}


\begin{document}

\section*{Bugs in OpenSSH}
\setcounter{section}{1}

\subsection{CVE-2016-0777 - Information Leak}
OpenSSH client versions between 5.4 and 7.1 are vulnerable to an information leak. The information leak occurs due to an experimental \textit{roaming} feature enabled by default. The \textit{roaming} feature allows a client to buffer input and re-send the buffer to an OpenSSH server on re-connect. This feature, however, uses an unsafe \texttt{malloc} call to allocate a buffer on the heap. A potential attacker may be able to read data from a previously de-allocated buffer, including private keys of the client \cite{QualisOpenSSH}.

The immediate remedial action is to update \texttt{ssh\_config} (global, or all local) and include \texttt{UseRoaming no} to disable the roaming feature. Alternatively, all \texttt{ssh} sessions can be executed with the \texttt{UseRomaing no} flag. The second immediate remedial action is to re-issue all private keys as the attack may have been exploited in the 'wild' allowing for an attacker to have already stolen the private key.

\subsection{CVE-2016-0778 - Buffer Overflow}
OpenSSH client versions 5.x, 6.x and 7.1.p2 \cite{NVD_CVE-201600778} are vulnerable to a file descriptor heap buffer overflow causing a denial of service or arbitrary code execution \cite{RedHat_CVE-201600778}. In order for this vulnerability to be exploited, two non-default configurations of the OpenSSH client are required - "ProxyCommand, and either ForwardAgent (-A) or ForwardX11 (-X)" \cite{QualisOpenSSH}.

The immediate remedial action is the same as for \textit{CVE-2016-0777}, \texttt{roaming} should be disabled and private keys should be re-issued.

\setcounter{section}{1}
\section*{2}
A CVSS score is an attempt at standardization of the seriousness of a vulnerability given its \textit{exploitability metrics}. The scores range from 0 to 10 with 10 being the most severe. Each metric contributes to the overall seriousness of an exploit, the total being used as the \textit{base score}.

\setcounter{section}{1}
\subsection*{Exploitability Metrics}
\begin{multicols}{2}
  \begin{enumerate}
      \item Attack Vector (AV)
          \begin{enumerate}
              \item Network (AV:N)
              \item Adjacent Network (AV:A)
              \item Local (AV:L)
              \item Physical (AV:P)
          \end{enumerate}

      \item Access Complexity (AC)
          \begin{enumerate}
              \item Low (AC:L)
              \item High (AC:H)
          \end{enumerate}

      \item Privileges Required (PR)
          \begin{enumerate}
              \item None (PR:N)
              \item Low (PR:L)
              \item High (PR:H)
          \end{enumerate}

      \item User Interaction (UI)
          \begin{enumerate}
              \item None (UI:N)
              \item Required (UI:R)
          \end{enumerate}

      \item Scope (S)
          \begin{enumerate}
              \item Unchanged (S:U)
              \item Changed (S:C)
          \end{enumerate}

      \item Confidentiality Impact (C)
          \begin{enumerate}
              \item None (C:N)
              \item Low (C:L)
              \item High (C:H)
          \end{enumerate}

      \item Integrity Impact (I)
          \begin{enumerate}
              \item None (I:N)
              \item Low (I:L)
              \item High (I:H)
          \end{enumerate}

      \item Availability Impact (A)
          \begin{enumerate}
              \item None (A:N)
              \item Low (A:L)
              \item High (A:H)
          \end{enumerate}
  \end{enumerate}
\end{multicols}

\textit{CVE-2016-0777} can be exploited over the network (AV:N), an attacker can expect repeated success of the attack as the complexity is low (AC:L), the exploit only requires user permissions (PR:L), it does not require any user interaction (UI:N), it comprises high confidentiality impact (C:H), there is no integrity impact (I:N) and it does not affect availability (A:N). The CVE is characterized as having severity of \textit{Medium (4.0-6.9)}.

\textit{CVE-2016-0778} can be exploited over the network (AV:N), it is low in exploit complexity (AC:L), does not require any special privilege (PR:N), no user interaction is required (UI:N) and the impact is high for confidentiality (C:H), high for integrity (I:H) and high for availability (A:H). The CVE is characterized with severity \textit{Cricial (9.0 - 10.0)}. 

CVE-2016-0778 is more severe based on the score.

\setcounter{section}{2}
\section*{3}
Firstly, a code review process would have increased the chances of finding the buffer overflow vulnerability in CVE-2016-077. The code review could initially focus on the correctness of the implementation, however, it should also consider real world statistics on common vulnerabilities and focus on mitigation of such scenarios (CR1.1: 18) \cite{BSIMM6-CodeReview}.

Secondly, automated tools to check for the usage of commonly vulnerable APIs could be used to identify potential attack vectors before the code is deployed. This activity involved using real world data on vulnerability analysis and the respective security issues within the implementation to create an early warning system of unsafe API usage (CR1.4:55) \cite{BSIMM6-CodeReview}.

Thirdly, the operation of an official bug bounty program could lead to a higher number of vulnerabilities discovered as it provides an incentive for security researchers to analyze the application (CMVM3.4) \cite{BSIMM6-BugBounty}. The vulnerabilities could have been discovered by independent testing and study of the source code. 

\setcounter{section}{3}
\section*{4}
In order to consider the relative merits of switching away from OpenSSH to the new system (let us call the system NewSSH), we have evaluate a range of aspects such as the exposure minimization, the operational model of the server (including other software dependency) with NewSSH, the development and maintenance principles of NewSSH as well as the the metrics used to evaluate the relative gain from switching to NewSSH.

Firstly, theoretically switching to NewSSH can mitigate exposure to vulnerabilities. For example, a vulnerability found in OpenSSH may no longer have any impact on our system running NewSSH. This assumption, however, relies entirely on the implementation of NewSSH. A vulnerability exploiting the specification protocol of SSH may render both systems equally vulnerable. By switching to NewSSH, we are only protecting ourselves from vulnerabilities found in OpenSSH, not vulnerabilities that may be discovered in NewSSH.

Secondly, the operational model of the SSH server is important. A server side switch from OpenSSH to NewSSH may not be able to protect against vulnerabilities found in the client side either application. If the majority of users of the SSH server maintain their usage of OpenSSH, then switching to NewSSH has not decreased our exposure to client side vulnerabilities. This is in fact the case of CVE-2016-0777/8. Additionally, a closed source or a proprietary implementation of NewSSH may in fact increase exposure due to undiscovered vulnerabilities as well as making an object analysis of the security model of NewSSH difficult to obtain.

Thirdly, the development and maintenance principles of NewSSH play an integral role. It is generally assumed that a widely adopted open source application will have had a large number of code reviewers and security researches scrutinizing the source code and patching vulnerabilities as quickly as possible. On the other hand, a potentially closed source or less popular implementation may have a significantly lower number of reviewers and experts involved in the development cycle.

Moreover, the number of CVEs or major vulnerabilities found in either application is not a reasonable indicator of the level of security provided by either application. It could be argued that the larger the number of CVEs reported, the more secure an application ought to be. Alternatively, considering the popularity of the package and the development principles (closed/open source) will affect the number of vulnerabilities discovered. This is due to a larger attack surface in terms of cost per client/server exploitable from the point of view of the attacker. More popular applications attract more attention and therefore also have a larger number of CVEs.

Furthermore, the number of CVEs in itself is not an indicator of security. Each CVE has a severity level, and therefore one would have to compare the severity of each CVE (score) rather than the total count.

I believe that the reasoning provided by my friend is insufficient to make an informed decision on whether switching away from OpenSSH would be beneficial. A deep analysis of both systems would be required in order to make a better informed decision.

\newpage
\section*{Buffer Overflow}
\setcounter{section}{1}

\section*{1 Exploitation Steps}
\begin{enumerate}
	\item Firstly, it is essential to gain an understanding of the program behavior. We begin by analyzing the program as a function of inputs and outputs. Inputting sample sequences of input such as \texttt{aaaa}, \texttt{abcd} or \texttt{0x00} and larger sequences such as \texttt{'a' * 128} yields the undesired \textit{Wrong Password, sorry!} message. From the test cases above, we know that the program is effectively making a comparison to some values rather than just being a dummy password challenge.
    \item Secondly, in order to analyze how the program performs the password validity check, we use \textit{gdb} to investigate and disassemble the binary. Running \texttt{disas /m main} inside \textit{gdb} yields the following: 
    \lstinputlisting{disass.txt}
    
    We can see there is a sequence of \texttt{movb} instructions setting bytes on an array (identifiable from increasing memory addresses). We can see that  Therefore, we know the passcode is stored in the binary itself. We can also observe that the input is being read with \texttt{scanf}. Furthermore, we can observe that there is an \texttt{MD5} call suggesting the password is being hashed.
    
    Settings breakpoints around the \texttt{scanf} call at \texttt{0x080486b1} and the \texttt{MD5} call at \texttt{0x8048520} we can inspect the memory structure before the user input, after the user input and after the hash. We use \texttt{'a' * 32} as input.
        \lstinputlisting{memdump.txt}
        
	We can observe that we can override the memory locations with input except for the final 3 bytes. The third last byte is the null character suggesting \texttt{scanf} is being used with an upper bound on the input it reads, in this case it reads 29 bytes and appends the null character.
	Additionally, after the MD5 is applied, only the first 16 bytes have been modified. Taking the MD5 hash of \texttt{'a' * 29} = \texttt{f7ce3d7d44f3342107d884bfa90c966a}, we can see that it matches the first 16 bytes of the after MD5 address values.
    
    \item Therefore, in order to pass the password check, we need to find a key, such that it's hash will end in the last 3 bytes we cannot overwrite. That is, we need a key which when MD5 hashed will contain \texttt{0x00 0x91 0xeb} as the last 3 bytes.
    
    \item In order to generate a key whose hash ends in \texttt{0x00 0x91 0xeb}, we generate a random key, calculate the hash and verify the results matches. This can be computationally expensive, however, knowing only the last 3 bytes of the hash match, we reduce the search space significantly. The following python code does finds the required key and corresponding hash.
    \lstinputlisting[language=Python]{find_hash.py}
    
    One possible key-hash pair is \texttt{FQ3hQntC}-\texttt{fe91pf7b6a7u9e11Qa3eacf0091eb}. Considering our key is 8 bytes long, we need to add padding to increase it's size to 16 bytes. We can use the null character to do so. The resulting input  which exploits the binary is then (split onto lines for legibility):
        \lstinputlisting{exploit_hash.txt}
        
    Testing this input with the vulnerable program we receive \textit{Correct Password!}.
    
\end{enumerate}

\section*{2 Exploit}
In order to produce a script which automatically exploits the program, we can either dynamically generate a key-hash pair which will exploit the program or such a hash can be pre-computed. The submitted \texttt{exploit} script contains both versions with the pre-computed approach select by default. The \texttt{./exploit} is written in Python and requires to have executable permissions set. To exploit the \texttt{vulnerable} program, run \texttt{./exploit ./vulnerable}.

\section*{3 Patch}
Patch is attached to the submission. It consists of fixing the buffer overflow in the number of characters scanned in \texttt{scanf}. Additionally, it increases the size of the password buffer by 1 byte in order to allow for the null terminated character \texttt{scanf} appends.


\newpage
\section*{Web Security}
\setcounter{section}{1}

\section*{1 XSS}
An Cross Site Scripting (XSS) attack generally takes the form of malicious user input which is exposed to other users. A such input may include scripting elements allowing an attacker to modify the behavior of the victims view. 

Generally, for an XSS attack to be useful, it is desirable to perform an XSS attack in areas of the site restricted to users with a certain level of permission - for example after logging in or in administration mode.

In order to perform an XSS attack on the Image Voting System, we first analyze the system behavior. By logging in as a regular user, we can observe the behavior of the system, paying particular attention to areas where user input is used as part of the site's output. For initial analysis of the site, Chrome Web Developer tools with network and source code analysis suffice to obtain a better picture of the underlying system.

Firstly, we perform the following actions:
\begin{enumerate}
	\item Log in with \texttt{user1:user1}
    \item Post a url such as \texttt{\url{https://imgs.xkcd.com/comics/toasts.png}}
    \item Inspect the returned response after submission
    \item Post non-url text such as \texttt{<div>'"</div>} and observe the exact format of the response
\end{enumerate}

With the above simple steps, we can already make an educated guess on how the server is implemented, we can derive the following:

\begin{itemize}
	\item The Server side processor is PHP 5.5.9
    \item X-XSS-Protection header is set to 0
    \item The API to post a link is \texttt{HTTP POST http://localhost:8080/index.php} with form data containing the \texttt{link} attribute with the url we submitted.
    \item The response is rendered inside an \texttt{<img src='\url{https://imgs.xkcd.com/comics/toasts.png}'>} element
    \item Non-URL text appears to not be sanitized and is rendered as-is inside the \texttt{src} attribute
\end{itemize}

Armed with this knowledge, we can craft an XSS attack by ensuring we break out of the closing quote as part of our request and inject malicious code. The following does the trick as well as covers up the malformed request by also displaying an image.

\texttt{\linebreak' style="display: none" />
\linebreak<script>alert("Hello World!")</script>
\linebreak<img src='//imgs.xkcd.com/comics/toasts.png
}
\linebreak

The resulting site will display the following:

\lstinputlisting[language=HTML]{xss.html}

Any visitor of the site will now receive an \texttt{index.php} site containing our malicious script. A serious XSS attack could attempt to steal login credentials (and send them to C\&C) and gain access to a user's account or perform any other action while acting as the currently logged in user.

\section*{2 CSRF}
A Cross Site Request Forgery (CSRF) attack aims to exploit a another user (victim) to perform an action which they did not intend to make. In order to perform a CSRF attack, we need to understand the system implementation and what action we may want to utilize perform the exploit. In order to gain this insight, let us perform a few actions:

\begin{itemize}
	\item Submit an image \texttt{\url{https://imgs.xkcd.com/comics/toasts.png}}
    \item Click 'Vote for me' on David's image
    \item Click 'Vote for me' on our own image
\end{itemize}

From the above actions, we know the following:
\begin{itemize}
	\item We are \texttt{user1}
	\item Voting for David makes an \texttt{HTTP GET http://localhost:8080/vote.php?vote=david}, presumably voting for user1 would only require changing the query parameters
    \item Voting for ourselves fails with an check on the currently logged in user, we can confirm voting for user1 requires to change the query params.
\end{itemize}

Therefore, we would like to get other users (victims) to unknowingly vote for our own image. We can notice that voting is a GET method, which is incorrectly implemented on the server as a GET action ought to be idempotent, however, in this case it causes side effects - increments vote counter. When a browser is presented with a request to retrieve an image, it will make an \texttt{HTTP GET [url]} request to retrieve the content. The browser cannot distinguish an action such as voting from retrieving an image and therefore, we can use the url API of the 'Vote' action to be fetched by the victims browser and in fact vote for us. To do this, we craft can simply insert \texttt{http://localhost:8080/vote.php?vote=user1} as the image url. This will, however not render an image and may appear suspicious. Instead, we can hide the request inside a \texttt{background-image} style property. Inserting the following will do the trick:

\texttt{
\newline //imgs.xkcd.com/comics/toasts.png' 
\newline style="background-image: url('vote.php?vote=user1')" '}

When we (user1) view the site, the count is not incremented as the server prevents us doing so - just as if we clicked the 'Vote for me' button on our own image.

When any other users (victims) view the site, the browser will make a GET request with their credentials and execute the vote. What's more, every reload of the site will increment the vote further.

An alternative method to perform a CSRF attack is to spoof the session ID. Looking at the headers the server sets, we can observe that each request contains the following:
\texttt{Cookie: username=user1; session=24c9e15e52afc47c225b757e7bee1f9d}. The session appears to be a hash of some sort, we can use Rainbow Tables to attempt to find a corresponding plaintext for the hash. Using \url{md5cracker.org}, we can quicky find that the hash \texttt{24c9e15e52afc47c225b757e7bee1f9d} corresponds to \texttt{md5(user1)}, therefore we know the server simply MD5 hashes the username. Armed with this knowledge, we can generate an MD5 hash for user \texttt{joseph} to get \texttt{\newline md5(joseph) => cb07901c53218323c4ceacdea4b23c98}, changing the Cookie headers to these values allows us to login as \textit{joseph} and therefore vote for anyone. This exploit requires the knowledge of other usernames on the system.

\section*{3 Security Audit}
\subsection*{Generate less predictable session keys}
In order to improve security, we can issue session keys which appear more random, that is, decrease the probability an attacker will be able to discover the pattern/scheme used to generate the session key and therefore decrease chances of session hijack.

We can achieve this by using a server-side only salt hash. This salt can be added to the username in order to generate a new session key. The scheme can look like this:
\lstinputlisting[language=PHP]{salt.txt}

An attacker may no longer directly look up the common hashes of the username as the salt has been factored into it. However, an even better solution would be to use session cookies which will expire on the server side after a fixed amount of time. This can be achieved by keeping a key-value store of session cookies which will automatically expire after a given duration. A Redis/memcached server could be used to achieve this with relative simplicity. The timed expiration of a session key improves security as old session keys are no longer valid and therefore stolen session keys become obsolete with time.

\subsection*{Lock down debugging and admin configuration}
When running a web application in production, debugging information as well as any other tools exposing system internals should not be exposed. In the case of the Online Image Voting system, there are multiple configuration issues.

Firstly, the site should not be running in debugging mode. In the source code we can observe that the configuration option to display errors has been enabled. Indeed, we can also discover this by deliberately introducing syntactical errors in the source code which will result in error messages printed into the page. An unintended consequence is portions of the back end implementation leaking to the attacker therefore increasing exposure. In order to remedy this, we should turn off the \texttt{display\_errors} option, it should be set to \texttt{Off}. In fact, the source code should at no point attempt to set configuration options dynamically, the options should be defined and kept fixed from the start of the application. This allows for a much tighter control over the configuration options as well as keeping configs in the same place - reducing the chance of a human mistake to miss an occurrence. 

Secondly, we should not expose any system level configuration such as admin panels. In the case of our system, going to \texttt{localhost:8080/include/.admin.php} we can list all of the configuration attributes of the PHP system including session information and database configurations. On top of that, we can also see the list of installed packaged further increasing an attack surface. This file, \texttt{.admin.php} should be located outside of the served directory or it should not be part of the production system at all.

Thirdly, inspecting the headers we notice that the \texttt{X-XSS-Protection} header has been turned off. This option in itself does not guarantee XSS protection, rather it is a hardening setting. Modern browsers implement protections against common Cross Site Scripting patterns and are able to block such attempts. Even in development environments, it is unreasonable to disable the protection. We can enable it by setting the header inside \texttt{include/functions.php} to \texttt{X-XSS-Protection: 1; mode=block}. 

\subsection*{Remove database file from served directory}
The database should only be accessible through the API the server defines. This allows the API designers to enforce access restrictions and limit exposure. In the Image Voting System, the database file is accessible through \texttt{localhost:8080/db/imagevoting.db} and can be easily downloaded by an attacker. The database file should be located outside of the directory served by Apache. We can move the file outside of the \texttt{http} directory and put it into \texttt{/srv/db/imagevoting.db}. With that change, we also need to update the php confifuration file to allow it to access the new db directory. We can modify \texttt{/etc/php/php.ini} adding our path to the \texttt{open\_basedir} option. It would also be sound to remove all other paths such as \texttt{:/home/:/tmp/:/usr/share/pear/:/usr/share/webapps/} as we want to enforce the least level of access. Finally, we update the path to the database file inside \texttt{include/functions.php} to point to this new file. Restarting the service yields the desired results.

\subsection*{Sanitize inputs}
Finally, an essential step is to sanitize input url we are expecting to receive from the user. We can utilize some utilization functions built into PHP to simplify this process. Using the \texttt{filter\_var} method, we can specify we are interested in filtering to a URL. Therefore, the resulting change becomes: 

\lstinputlisting[language=PHP]{sanitize.txt}

If the input matches a URL, then it's allowed through, otherwise the content becomes empty. In a real system, we would want to indicate action failure, however, for this toy system it is sufficient to secure the input.


\newpage
\bibliographystyle{plain}
\bibliography{references}

\end{document}