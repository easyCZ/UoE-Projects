When first Netscape engaged in direct competiton with Microsoft for the browser of the web, it was apparent that the ability to support client side scripting could provide an edge and deliver marker share [1]. When finally Brendan Eich, a Netscape employee at that time, developed JavaScript in 10 days, it became part of the Netscape Navigator 2.0 in 1995 and thus JavaScript was born. Time has gone by with JavaScript mostly being used for cliend side scripting until Ryan Dahl paired Google's V8 JavaScript engine with an event loop resulting in the first build of Node.js which supported JavaScript on the server side. Shortly after, the Node Package Manager was born and the ecosystem of JavaScript has sky rocketed. Developers rejoiced and started embedding JavaScript in, well, everything - servers, smartphones, RaspberryPIs, smart fridges and even launching rockets has become a domain for Javascript [3]. It has effectively become the most popular language [4] by GitHub metrics.

Figure 1 - JavaScript is the most popular language on GitHub
With the unprecedented rise of JavaScript, a direct question arises - what is next? Alternatively, one might ask how will the change of the software development ecosystem be impacted by JavaScript. This article explores the aspects making JavaScript a rockstar as well the impact it has had on the development of software development paradigms and practices for the future. In particular, the article will focus on the development lifecycle transformation, the quality of software as well as peek at projects aiming to mitigate questionable design choices made during JavaScript's rather short design & development period.

The development lifecycle of an application is an essential attribute a software product must consider. In terms of programming language, the lifecycle can be broken down to the following: development & testing and deployment. JavaScript solves deploymnet through the use of the web infrastructure as well as the web browser, however, development and testing are areas that JavaScript can provide lessons relevant for the future of software. I will in turn discuss each of the categories with respect to JavaScript, the present and the direction it is heading in. In the context of the development lifecycle, I will focus on applications involving a user interface.
Development
In the context of JavaScript, the development of an application generally aims to capture and implement the logic powering a user interface running in a web browser. In its vanialla version, it is an interpreted and dynamically typed language. As a result, in the simplest form an iteration on development requires no more than a code change and a reload of a browser. This is as opposed to compiled languages where the time between a code change and the effect is more significant. I believe this is an essential aspect in modern application development and here is why.
Firstly, development of user interfaces requires fast iteration on changes. An instant feedback of a code change increases developer productivity. The current development practices of JavaScript frequently include a 'live reload' feature (5). Live reload aims to solve the problem of instant feedback by reloading a web browser on a code change. This has a large effect on the speed of development as we no longer even require to switch to a browser and reload it manually. However, this is short of the current state of the art feature called 'stateful hot loading'. This feature allows an application to retain state while updating its implementation. Stateful hot loading is for example implemented by react-transform (6) or React-Native (7) which goes as far as allowing developers to implement mobile applications in JavaScript, with the fast development lifecycle while also retaining the ability to run as a native application with native speed. In the future, software architectures capable of supporting instantaneous feedback and faster development experience are more likely to succeed.

Figure 2 - Sample Stateful Hot Loading

Secondly, code quality matters. Vanilla JavaScript provides little to no help for structured and scalable (code size) applications. However, the ecosystem has matured sufficiently and developed a wide range of transpilers in order to overcome common difficulties encountered in JavaScript development. For example, the 'not yet supported' recent specification of ES2015 (ES6) is the next generation standard for JavaScript and enhances the language with additional features. Despite not being fully supported by modern browsers, applications written in the new standard can be transpiled into vanilla JavaScript without affecting functionality. Similarly, TypeScript, a superset of JavaScript with types, can be used to increase the quality of code. As a result, JavaScript can provide similar capabilities as compiled languages with the benefit of remaining simple. In the future, architectures which are extensible are more likely to be successful.
Thirdly, the ecosystem is your friend. JavaScript ecosystem adopts a similar approach to the command line - build many small applications/libraries in order to obtain flexibility as well as ability to build on top. As a result, utilizing open source software as building blocks for an application greatly enhances the speed of development as well as quality. For JavaScript, the Node Package Manager became the major selling point providing simplicity as well as a large number of building blocks. 
Instant feedback, extensibility and the ecosystem all play an essential role in the popularity of JavaScript. JavaScript may not be the future of software architecture, however, the process of developing JavaScript applications has had an impact on how an effective development process may look like in the future.
Testing
Testing is hard. Testing user interfaces is even harder. JavaScript itself does not make this process any easier. However, the approach to testing user interfaces has significantly improved through the development of JavaScript UIs. The main approach to testing user interfaces today is through webdrivers (8). A webdriver is an API capable of simulating user activities such as clicking, dragging, typing and so on. A test suite can be scripted and automated and act the same way an application user would, in most cases. However, even webdriver is not solving the underlying problem of user interaface testing which relies mainly in unpredictable information flow. Complex javascript applications often rely on asynchronous requests to lazy-load data, state transitions and information flow between connected components. A concept first introduced by Facebook as the 'Flux Architecture' (9) aims to alleviate this problem. Information is only allowed to flow in one direction, that is, from a data store to its connected components effectively rendering the data store the source of 'truth'. This simple, yet powerful concept has had an immense impact on the design of user interfaces. The state of the art implementation of the Flux architecture in the JavaScript world is 'Redux' (10). Redux couples the Flux architecture with immutable state and allows a developer to describe an application as a sequence of actions which result in states, effectively a finite state machine. This almost obvious design choice has had a ripple effect on how developers approach UI design and testing. Testability is greatly improved by having a well defined model of state. We see adoption of concepts such as immutability, which were previously foreign to javascript, help drive the overall outlook at UI testing.
Future
JavaScript may, or may not, be the future. And it does not matter. Programming language trends change over time, however, I believe that the lessons JavaScript has been able to teach us about instant feedback, extensibility, the importance of the ecosystem and finally about testing are of a much greater importance and likely to play a significant role in the future. Whether it is a future where we program spaceships in JavaScript or in {{ insert your own next best programming language here }} is of a lesser signifiance the evolution of software architecture.
